// src/common.ts
import {
  createServer as createHttpServer
} from "http";
function createMiddleware(handler, options = {}) {
  const {
    origin = process.env.ORIGIN,
    trustProxy = process.env.TRUST_PROXY === "1"
  } = options;
  let { protocol, hostname } = origin ? new URL(origin) : {};
  return async (req, res, next) => {
    function getForwardedHeader(name) {
      return (String(req.headers["x-forwarded-" + name]) || "").split(",", 1)[0].trim();
    }
    protocol = protocol || req.protocol || trustProxy && getForwardedHeader("proto") || req.socket.encrypted && "https" || "http";
    hostname = hostname || trustProxy && getForwardedHeader("host") || req.headers.host;
    const ip = req.ip || trustProxy && getForwardedHeader("for") || req.socket.remoteAddress || "";
    const request = new Request(protocol + "://" + hostname + req.url, {
      method: req.method,
      headers: req.headers,
      body: req.method === "GET" || req.method === "HEAD" ? void 0 : req
    });
    let passThroughCalled = false;
    const context = {
      request,
      ip,
      waitUntil(promise) {
      },
      passThrough() {
        passThroughCalled = true;
      },
      platform: {
        request: req,
        response: res
      }
    };
    const response = await handler(context);
    if (!next || !passThroughCalled) {
      res.statusCode = response.status;
      for (const [key, value] of response.headers) {
        if (key === "set-cookie") {
          const setCookie = response.headers.getSetCookie();
          res.setHeader("set-cookie", setCookie);
        } else {
          res.setHeader(key, value);
        }
      }
      const contentLengthSet = response.headers.get("content-length");
      if (response.body) {
        if (contentLengthSet) {
          for await (let chunk of response.body) {
            chunk = Buffer.from(chunk);
            res.write(chunk);
          }
        } else {
          const reader = response.body[Symbol.asyncIterator]();
          const first = await reader.next();
          if (first.done) {
            res.setHeader("content-length", "0");
          } else {
            const secondPromise = reader.next();
            let second = await Promise.race([
              secondPromise,
              Promise.resolve(null)
            ]);
            if (second && second.done) {
              res.setHeader("content-length", first.value.length);
              res.write(first.value);
            } else {
              res.write(first.value);
              second = await secondPromise;
              for (; !second.done; second = await reader.next()) {
                res.write(Buffer.from(second.value));
              }
            }
          }
        }
      } else if (!contentLengthSet) {
        res.setHeader("content-length", "0");
      }
      res.end();
    }
    next == null ? void 0 : next();
  };
}
function createServer(handler, adapterOptions, serverOptions) {
  const listener = createMiddleware(handler, adapterOptions);
  return serverOptions ? createHttpServer(serverOptions, listener) : createHttpServer(listener);
}

export {
  createMiddleware,
  createServer
};
